{{partial_1}}/** 
 * @class CardList
 * @namespace components 
 * @description 
 * @author Playbook
 */
import React, { Fragment } from 'react';
import PropTypes from 'prop-types';
import { Draggable, DraggableProvided, Droppable, DroppableProvided } from 'react-beautiful-dnd';

/**
 * @requires Styles
 */
import './card-list.styles.css';


/**
 * @requires Components
 */
import Card from '../card/card.component';

/**
 * @required Types
 */
type TCardData = {
    id: number;
    position: string;
    name : string;
}

/**
 * @param {TProperty} TProperty 
 */
type TProperty = {
    listId: number;
    name : string;
    cardsData? : TCardData[]; // -- Raw card data. May not be in order. Used to construct the state
}

/**
 * @param {TState} TState
 */
type TState = {
    cardsData? : TCardData[] // -- Cards data in order. Used for rendering
}

/**
 * CardList
 *
 * @class CardList
 * @extends {React.Component<TProperty, TState>}
 */
class CardList extends React.Component<TProperty, TState> {

    /**
     * @param {PropTypes} propTypes - property types to check at run time 
     */
    static propTypes = {
        listId: PropTypes.number.isRequired,
        name : PropTypes.string.isRequired,
        cardsData : PropTypes.arrayOf(Object)
    }


    /**
     * Generate a state for use in the next render.
     * 
     * We will use this to re-order the cardsData provided by props and save it to the state for render
     * to read from
     *
     * @static
     * @memberof CardList
     */
    static getDerivedStateFromProps (props: TProperty, state: TState)
    {
        let cardsDataOrdered = props.cardsData ? [...props.cardsData] : [];

        /**
         * @description Clean the cardsData first to ensure it contains the required props
         */
        cardsDataOrdered = cardsDataOrdered.filter((cardData: TCardData) => {
            return cardData.id && cardData.name && cardData.position;
        })

        /**
         * @description Sort the cleaned data by position
         */
        cardsDataOrdered = cardsDataOrdered.sort((cardDataA: TCardData, cardDataB: TCardData): number => {
            return cardDataA.position.localeCompare(cardDataB.position);
        })

        /**
         * @description Return the new state with the cardsDataOrdered
         */
        return {
            cardsData: cardsDataOrdered
        }
    }

    /**
     * Constructor of the CardList. Useful to intialise state properties and bind any 
     * instance functions with context
     * 
     * @param {TProperty} props
     * @memberof CardList
     */
    constructor(props: TProperty)
    {
        super(props);

        this.state = {
            cardsData : []
        }
    }

    /**
     * Render the CardList
     *
     * @returns {JSX} component 
     * @memberof CardList
     */
    render() {

        /**
         * @task Create the array of <Card /> components
         */
        let cardComponents: JSX.Element[] = [];

        /**
         * @description Because cardsData is optional, we will need to check if the property exists
         */
        if (this.state.cardsData)
        {
            /**
             * @description We will use the build-in array function "map" to iterate over every object inside the cardsData array.
             *              This will return us a new array with the Card components ready to use
             */
            cardComponents = this.state.cardsData.map((cardData: TCardData, cardIndex: number): JSX.Element => {

                /**
                 * @description Before creating the Card component, we will need to check if the 
                 *              name property exists inside cardData
                 */
                if (cardData.hasOwnProperty('id') && cardData.hasOwnProperty('name'))
                {
                    /**
                     * @description Because we are returning an array of Cards, we will also need to supply a required React property "key" 
                     *              (any value that uniquely identifies each item within this array) so for now, we will use the array index.
                     * 
                     *              The card will be wrapped in a Draggable component and this component will take in a function that generates a JSX.Element.
                     *              This function is passed a provided object (generated by DragDropContext) which will be used to build our draggable card
                     * 
                     *              Due to library requirements, an additional div (the div is required by react-beautiful-dnd as it needs to 
                     *              target an HTMLElement, not a react component https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md)
                     */
                    return (
                        <Draggable
                            draggableId={"card-" + cardData.id}
                            index={cardIndex}
                            key={"card-" + cardData.id}
                        >
                            {(provided: DraggableProvided) => {
                                return (
                                    <div
                                        ref={provided.innerRef}
                                        {...provided.dragHandleProps}
                                        {...provided.draggableProps}
                                    >
                                        <Card 
                                            name={cardData.name}
                                        />
                                    </div>
                                )
                            }}
                            
                        </Draggable>
                    );
                }

            })
        }

        return (
            <div className="cardListComponent">
                <div className="cardListName">
                    { this.props.name }
                </div>
                {/* We will be setting the cardContainer as the drop zone for all cards. This will also require a function to be run by the Droppable Component */}
                <Droppable
                    droppableId={"list-" + this.props.listId }
                >
                    {(provided: DroppableProvided) => {
                        return (
                            <div 
                                className="cardContainer" 
                                data-testid="cardList.cardContainer"
                                ref={provided.innerRef}
                            >
                                {/* Here we use curly brackets the same way we do with properties, only this time we are inserting an array */}
                                {cardComponents}

                                {/* This will allow the other draggables to reposition themselves to allow a gap for the card we are dragging  */}
                                {provided.placeholder}
                            </div>
                        )
                    }}
                </Droppable>
            </div>
        );
    }

{{partial_2}}    get orderedCardsData() {
{{partial_3}}    }

}

export {
    CardList
}


export default React.forwardRef((props: TProperty, ref: React.RefObject<any>) => {
    return (
        <CardList ref={ref} {...props} />
    )
});