# board Component (Scene for a visual component)
Holds a bunch of CardList components

### What we are working on

We have already implemented the drag and drop ability for cards and card-lists but the board was handling everything.
This seems fine from the board perspective but our `CardList` would never be able to correctly order its own `Cards`

Instead we are going to refactor the sort code from `Board` for `Cards` and move it to the `CardList`. We can read up on further
implementation in the `card-list.playbook.mdx`

With the updated `CardList` we can create a reference (using [React.createRef](https://reactjs.org/docs/refs-and-the-dom.html))
in the `Board` as we will need access to the sorted `cardsData`. We will create and save the reference (if it doesn't already exist)
in the render function everytime we create a `CardList`

By fetching the `cardsData` sorted by the `CardList` we are able to use the old code (with some variable changes) but we no longer need
to sort the cards for each list before setting the state. The `CardList/s` now sort themselves out!

Below, from step 3.3 will be similar but there are a few changes

1. Use getDerivedStateFromProps (built in react function) to create a state that has the ordered listsData
2. Lets define the `DragDropContext` property `onDragEnd` to handle the rules when a `Draggable` is dropped into any `Droppable`. Note this will also fire when we drag
   `Cards` into `CardList` so we will need to use the `Draggable` property `type` to differentiate between the draggable types
3. With the `onDragEnd` we will be given the properties `{ draggableId, source, destination, type }`. Basically, we will be told the draggable we just moved and the index (array index)
   we are trying to fit into. This has not modified the real state `listsData` so we will need do the following things
    1. Change path depending on the `type` (COLUMN or Else)
    2. if `COLUMN`
        1. Clone `this.state.listsData` to a new array object
        2. Using `draggableId` search for the list that we moved
        3. If `destination.index === 0`
            1. We are dragging to the start. Fetch the original `destination.index` from `this.state.listsData` clone and get its position.
               We will be generating a new position using the lexicographic util `generatePosition(null, {original0thPosition})`
        4. Else if `destination.index === this.state.listsData.length - 1`
            1. We are dragging to the end. Fetch the original `destination.index` and generate a position after it using the
               lexicographic function `generatePosition({originalEndPosition}, null)`
        5. Else 
            1. We are in the middle of 2 lists. Get the start list by using `this.state.listsData[destination.index - 1]` and
               the end list by using `this.state.listsData[destination.index]` and generate a new position with the lexicographic
               function `generatePosition({startList.position}, {endList.position})`
        6. Once this is done, save the state by using `this.setState({ listsData: listsData })` and render should correctly save the positions
    3. if `DEFAULT`
        1. Clone `this.state.listsData` to a new array object
        2. Get both the `CardListRef` and `listData`. This will be called the `cardListSourceRef` and `cardListSourceData`
        3. Using the `cardListSourceRef`, fetch the orderedCards from the ref. This should return either the cards in order or an empty array. Call this `cardsDataSource`
        4. Get the card by using `cardListSourceData[source.index]`. Let's call this `cardDataDropped`
        4. The `cardDataDropped` can either be repositioned in the same `listData` OR it could have been moved to a new `listData` so:
        5. If `source.droppableId != destination.droppableId`
            1. The `Card` has moved to a new `CardList` so we will need to find a new position and remove the `cardDataDropped` from the `cardListSourceData`
            2. Get both the destination `CardListRef` and `listData`. This will be called the `cardListDestinationRef` and `cardListDestinationData`
            3. Use the `cardListsDestinationRef` to get the orderedCards Call this `cardsDataDestination`
            4. First remove the `source.index` from the `cardListSourceData` using `Array.splice({source.index}, 1)`
            5. If `cardsDataDestination.length === 0`
                1. All we need to do is `generatePosition()` for the `cardDataDropped`
            6. If `destination.index === 0`
                1. Dragging to the start. Fetch original card at `destination.index` from `cardsDataDestination` and get its position value.
                   We will generate a new position with the lexicographic util `generatePosition(null, {original0thPosition})`
            7. Else if `destination.index === cardsDataDestination.length` *(do not use -1 as the `cardDataDropped` has not yet been added!)*
                1. We are dragging to the end. Fetch the original `destination.index - 1` and generate a position after it using
                   the lexicographic util `generatePosition({lastCardPosition}, null)`
            8. Else
                1. We are in the middle of 2 cards. Get the start card by using `cardsDataDestination[destination.index - 1]`. Lets call this `cardStart`
                   Also get the end card by using `cardsDataDestination[destination.index]`. Let's call this `cardEnd`.
                   Using both these cards, generate a new position with the lexicographic util `generatePosition(cardStart.position, cardEnd.position)`
            9. Our `cardDataDropped` should now have the correct position so lets add it to the array by using `cardsDataDestination.push(cardDataDropped)`
        6. Else
            1. The `Card` has a new position in the same `CardList`
            2. If `destination.index === 0`
                1. Dragging to the start. Fetch original card at `destination.index` from `cardsDataSource` and get its position value.
                   Generate a new position with the lexicographic util `generatePosition(null, {original0thPosition})`
            3. Else if `destination.index === cardsDataSource.length - 1`
                1. We are dragging to the end. Fetch the original `destination.index - 1` and generate a position after it using
                   the lexicographic util `generatePosition({lastCardPosition}, null)`
            4. Else
                1. We are in the middle of 2 cards. Get the start card by using `cardsDataSource[destinationIndex - 1]`. Let's call this `cardStart`
                   Also get the the end card by using `cardsDataSource[destinationIndex]`. Let's call this `cardEnd`.
                   Using both these cards, generate a new position with the lexicographic util `generatePosition(cardStart.position, cardEnd.position)`
        7. Finally, save the state using `setState`


## Steps 
### Wireframe/Design 
* Design 
*  

### Component 
#### Structure
The board should contain a name and a container that can hold a bunch of card lists

* Component
    * Board name
    * DragDropContext
        * Droppable
            * CardList container
                * Draggable
                    * <card-list.component.tsx\>
                * Draggable
                    * ...
                * Draggable
                    * <card-list.component.tsx\>


***

### Story 
We should have a single board component that has dynamic props which are editable using storybook knobs

The card lists should also be moveable and should only land within the card list container

***

### Unit Test
* We will add a proptypes unit test to the Board component
    * name
    * listsData

* The listsData prop should be an optional prop

* The lists data should be an array that contains an object with the following keys
    * id
    * position (generated by lexicographic util)
    * name
    * cards (array)
        * id
        * name

* Test what we should render when the listsData that is passed in is
    * Valid - Print the list to the screen
    * Invalid - Skip the list with invalid data
    * Mixed - Print valid and skip invalid
    

***

### BDD Test 
* When we load the Board to the screen,
We will see the board name and
We will see 2 card lists and
Each list will have 2 cards each

    Given I have a Board
    When I look at it
    Then I should see the name of the board
    And I should see 2 card lists with the names of 'List 1' and 'List 2'
    And 2 Cards on each list with the names of 'Card 1', 'Card 2', 'Card 3' and 'Card 4'
