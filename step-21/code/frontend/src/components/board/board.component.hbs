/** 
 * @class Board
 * @namespace components 
 * @description 
 * @author Playbook
 */
import React, { Fragment } from 'react';
import PropTypes from 'prop-types';
import { DragDropContext, Draggable, DraggableProvided, Droppable, DroppableProvided } from 'react-beautiful-dnd';

import { generatePosition } from '../../common/utils/lexicographic.util'

/**
 * @import Components
 */
import CardList from '../card-list/card-list.component';

/**
 * @import Styles
 */
import './board.styles.css';
import generate from '@babel/generator';

/**
 * @import Types
 */
type TCardData = {
    id: number;
    position: string;
    name : string;
}
type TListData = {
    id : number;
    position: string;
    name : string;
    cards : TCardData[];
}

/**
 * @param {TProperty} TProperty 
 */
type TProperty = {
    name : string;
    listsData? : TListData[]
}
/**
 * @param {TState} TState
 */
type TState = {
    listsData? : TListData[] // -- This will contain the listsData but ordered by 'position'
}

/**
 * Board 
 *
 * @class Board
 * @extends {React.Component<TProperty, TState>}
 */
class Board extends React.Component<TProperty, TState> {

    /**
{{partial_1}}     * @param {PropTypes} propTypes - property types to check at run time 
     */
    static propTypes = {
        name : PropTypes.string.isRequired,
        listsData : PropTypes.arrayOf(Object)
    }
    
    /**
     * Everytime this.props changes, we can use the props to re-build this.state.
     * This is a built in react static function and because it is static, we will not have access to any non-static class properties
     * 
     * We will be taking the listsData passed in by this.props and sorting it using string sorts to get order the listsData in ascending order.
     * This will allow react-beautiful-rnd to print the lists in the correct order
     *
     * @static
     * @param {TProperty} props
     * @param {TState} state
     * @returns
     * @memberof Board
     */
    static getDerivedStateFromProps(props: TProperty, state: TState) {
{{partial_2}}
{{partial_3}}
{{partial_4}}
        return {
            listsData : listsDataOrdered
        }
    }


    constructor(props: TProperty)
    {
        super(props);

        /**
         * @description Initialising state. This is the only place we can do this.state. Everywhere else use this.setState.
         *              Initialisation is required as we use getDerivedStateFromProps and it throws a warning if we do not do this step
         */
        this.state = {
            listsData: []
        }

        /**
         * @description We are binding this function to allow it access to this classes instance. An alternative to this
         *              is to declare the function with fat arrow syntax
         */
        this.handleDragAndDropOnDragEnd = this.handleDragAndDropOnDragEnd.bind(this);
    }

    /**
     * Render the Board 
     *
     * @returns {JSX} component 
     * @memberof Board
     */
    render() {
        let cardListComponents: JSX.Element[] = [];

        /**
         * @description We are checking to see if there are listsData to build cardListComponents
         */
        if (this.state.listsData)
        {
            /**
             * @description Using array functions, iterate over the listsData and return JSX.Elements
             */
            cardListComponents = this.state.listsData.map((listData: TListData, listDataIndex: number) => {
                /**
                 * @description Check if the required props for the CardList before creating
                 */
                if (listData.hasOwnProperty('id') && listData.hasOwnProperty('name'))
                {
{{partial_5}}                    return (
                        <Draggable
                            key={"list-" + listData.id}
                            index={listDataIndex}
                            draggableId={"list-" + listData.id}
                        >
                            {(provided: DraggableProvided) => {
                                return (
                                    <div
                                        ref={provided.innerRef}
                                        {...provided.dragHandleProps}
                                        {...provided.draggableProps}
                                    >
                                        <CardList
{{partial_6}}                                            listId={listData.id}
                                            name={listData.name}
                                            cardsData={listData.hasOwnProperty("cards") ? listData.cards : null}
                                        />
                                    </div>
                                )
                            }}    
                        </Draggable>
                    )
                }
            })
        }


        return (
            <div className="boardComponent">
                <div className="boardName">
                    {this.props.name}
                </div>
                <DragDropContext onDragEnd={ ({ draggableId, source, destination, type }) => { this.handleDragAndDropOnDragEnd(draggableId, source, destination, type) }}>
                    <Droppable
                        droppableId="board-id" 
                        type="COLUMN" 
                        direction="horizontal"
                    >
                        {(provided: DroppableProvided) => {
                            // The data-testid is used by react-testing-library to find the container
                            return (
                                <div 
                                    ref={provided.innerRef}
                                    className="cardListContainer"
                                    data-testid="board.cardListContainer"
                                >
                                    {cardListComponents}

                                    {/* This will allow the other draggables to reposition themselves to allow a gap for the card we are dragging  */}
                                    {provided.placeholder}
                                </div>
                            )
                        }}
                    </Droppable>
                </DragDropContext>
            </div>
        );
    }


    /**
     * Handler for DragDropContext. Fires when a draggable lands in a droppable zone.
     * currently it handles CardList drops
     *
     * @param {string} draggableId
     * @param {{droppableId: string, index: number}} source
     * @param {{droppableId: string, index: number}} destination
     * @param {string} type
     * @memberof Board
     */
    handleDragAndDropOnDragEnd(
        draggableId: string, 
        source: {droppableId: string, index: number}, 
        destination: {droppableId: string, index: number}, 
        type: string) 
    {
        /**
         * @description First we will clone the state property, listsData, so we can make changes on it without modifying the state version
         */
        let listsDataCloned = [...this.state.listsData];

        /**
         * @description Split on the droppable type. We either be dealing with CardList(Column) or a Card(default)
         */
        if (type === "COLUMN")
        {
            /**
             * @description Fetch the list data from listsDataCloned that we just dragged and dropped
             */
{{partial_7}}                return ("list-" + listData.id) == draggableId;
            })

            /**
             * @description Lets take different paths depending on the destination.index
             */
            if (destination.index === 0)
            {
                /**
                 * @description We are dragging to the start. Get the original 0th position and generate a 
                 *              string position that is smaller
                 */
                const listDataEnd = listsDataCloned[0];

                /**
                 * @description Ensuring that the listDataEnd exists before we access it
                 */
                if (listDataEnd)
                {
                    /**
                     * @description Generate a position string that is smaller than the position of the listDataEnd
                     */
                    listDataDropped.position = generatePosition(null, listDataEnd.position);
                }
            }
            else if (destination.index === listsDataCloned.length - 1)
            {
                /**
                 * @description We are dragging the last position. Get the original last listData and
                 *              generate a new string position that is larger
                 */
                const listDataStart = listsDataCloned[listsDataCloned.length - 1];

                /**
                 * @description Ensuring that the listDataStart exists before we access it
                 */
                if (listDataStart)
                {
                    /**
                     * @description Generate a position string that is larger than the position of the listDataStart
                     */
                    listDataDropped.position = generatePosition(listDataStart.position, null);
                }
            }
            else
            {
                /**
                 * @description We are dragging between 2 existing ListData. Lets fetch both the start and end
                 */
                const listDataStart = listsDataCloned[destination.index - 1];
                const listDataEnd = listsDataCloned[destination.index];

                /**
                 * @description Ensuring that the listDataStart and listDataEnd exists before we access it
                 */
                if (listDataStart && listDataEnd)
                {
                    /**
                     * @description Generate a position string that is larger than the start position and smaller than the end position
                     */
                    listDataDropped.position = generatePosition(listDataStart.position, listDataEnd.position);
                }
            }

            /**
             * @description Finally re-sort the state as the static getDerivedStateFromProps will not fire for state changes
             */
            listsDataCloned = listsDataCloned.sort((listDataA: TListData, listDataB: TListData): number => {
                return listDataA.position.localeCompare(listDataB.position);
            });
        }
        else
        {
            /**
{{partial_8}}             */
{{partial_9}}            })

{{partial_10}}            {
                /**
{{partial_11}}                 */
{{partial_12}}
                /**
{{partial_13}}                 * @description Ensure the cardDataDropped exists
                 */
                if (cardDataDropped)
                {
                    /**
                     * @description Check if we are moving the card into a new card list or the same card list
                     */
                    if (source.droppableId != destination.droppableId)
                    {
                        /**
{{partial_14}}                         */
{{partial_15}}                        })

{{partial_16}}                        {
                            /**
{{partial_17}}                             */
{{partial_18}}
{{partial_19}}                            {
                                /**
                                 * @description There are no cards in the destination! Lets just set the default position and add the card directly
                                 */
                                cardDataDropped.position = generatePosition();
                            }
                            else
                            {
                                if (destination.index === 0)
                                {
                                    /**
                                     * @description We are dragging to the start. Get the original start card (we will call it cardDataEnd as it will follow after the new card)
                                     */
{{partial_20}}
                                    /**
                                     * @description Generate a new position with this cardDataEnd as the end point
                                     */
                                    cardDataDropped.position = generatePosition(null, cardDataEnd.position);
                                }
{{partial_21}}                                {
                                    /**
                                     * @description We are dragging to the end of the list. Get the last item and call it card start
                                     */
{{partial_22}}
                                    /**
                                     * @description Generate a new position with this cardDataStart as the start point
                                     */
                                    cardDataDropped.position = generatePosition(cardDataStart.position);
                                }
                                else
                                {
                                    /**
                                     * @description We are in the middle of 2 cards. Fetch the start and end cardData points
                                     */
{{partial_23}}
                                    /**
                                     * @description Generate a new position
                                     */
                                    cardDataDropped.position = generatePosition(cardDataStart.position, cardDataEnd.position);
                                }
                            }
{{partial_24}}                    }
                    else
                    {
                        /**
                         * @description The card is staying on the same list
                         */
                        if (destination.index === 0)
                        {
                            /**
                             * @description We are dragging to the start. Get the original start card (we will call it cardDataEnd as it will follow after the new card)
                             */
{{partial_25}}
                            /**
                             * @description Generate a new position with this cardDataEnd as the end point
                             */
                            cardDataDropped.position = generatePosition(null, cardDataEnd.position);
                        }
{{partial_26}}                        {
                            /**
                             * @description We are dragging to the end of the list. Get the last item and call it card start
                             */
{{partial_27}}
                            /**
                             * @description Generate a new position with this cardDataStart as the start point
                             */
                            cardDataDropped.position = generatePosition(cardDataStart.position);
                        }
                        else
                        {
                            /**
                             * @description We are in the middle of 2 cards. Fetch the start and end cardData points
                             */
{{partial_28}}
                            /**
                             * @description Generate a new position
                             */
                            cardDataDropped.position = generatePosition(cardDataStart.position, cardDataEnd.position);
                        }
{{partial_29}}
{{partial_30}}                }
{{partial_31}}            }
        }

        /**
         * @description Finally we save the state and let render do its thing
         */
        this.setState({
            listsData : listsDataCloned
        })
    }

}

export default Board;
