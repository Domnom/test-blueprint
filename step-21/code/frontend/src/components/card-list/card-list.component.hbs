/** 
 * @class CardList
 * @namespace components 
 * @description 
 * @author Playbook
 */
import React, { Fragment } from 'react';
import PropTypes from 'prop-types';
import { Draggable, DraggableProvided, Droppable, DroppableProvided } from 'react-beautiful-dnd';

/**
 * @requires Styles
 */
import './card-list.styles.css';


/**
 * @requires Components
 */
import Card from '../card/card.component';

/**
 * @required Types
 */
type TCardData = {
    id: number;
    position: string;
    name : string;
}

/**
 * @param {TProperty} TProperty 
 */
type TProperty = {
    listId: number;
    name : string;
{{partial_1}}}

/**
 * @param {TState} TState
 */
type TState = {
{{partial_2}}}

/**
 * CardList
 *
 * @class CardList
 * @extends {React.Component<TProperty, TState>}
 */
class CardList extends React.Component<TProperty, TState> {

    /**
     * @param {PropTypes} propTypes - property types to check at run time 
     */
    static propTypes = {
        listId: PropTypes.number.isRequired,
        name : PropTypes.string.isRequired,
        cardsData : PropTypes.arrayOf(Object)
    }

{{partial_3}}    /**
{{partial_4}}     * Render the CardList
     *
     * @returns {JSX} component 
     * @memberof CardList
     */
    render() {

        /**
         * @task Create the array of <Card /> components
         */
        let cardComponents: JSX.Element[] = [];

        /**
         * @description Because cardsData is optional, we will need to check if the property exists
         */
{{partial_5}}        {
            /**
             * @description We will use the build-in array function "map" to iterate over every object inside the cardsData array.
             *              This will return us a new array with the Card components ready to use
             */
{{partial_6}}
                /**
                 * @description Before creating the Card component, we will need to check if the 
                 *              name property exists inside cardData
                 */
                if (cardData.hasOwnProperty('id') && cardData.hasOwnProperty('name'))
                {
                    /**
                     * @description Because we are returning an array of Cards, we will also need to supply a required React property "key" 
                     *              (any value that uniquely identifies each item within this array) so for now, we will use the array index.
                     * 
                     *              The card will be wrapped in a Draggable component and this component will take in a function that generates a JSX.Element.
                     *              This function is passed a provided object (generated by DragDropContext) which will be used to build our draggable card
                     * 
                     *              Due to library requirements, an additional div (the div is required by react-beautiful-dnd as it needs to 
                     *              target an HTMLElement, not a react component https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md)
                     */
                    return (
                        <Draggable
                            draggableId={"card-" + cardData.id}
                            index={cardIndex}
                            key={"card-" + cardData.id}
                        >
                            {(provided: DraggableProvided) => {
                                return (
                                    <div
                                        ref={provided.innerRef}
                                        {...provided.dragHandleProps}
                                        {...provided.draggableProps}
                                    >
                                        <Card 
                                            name={cardData.name}
                                        />
                                    </div>
                                )
                            }}
                            
                        </Draggable>
                    );
                }

            })
        }

        return (
            <div className="cardListComponent">
                <div className="cardListName">
                    { this.props.name }
                </div>
                {/* We will be setting the cardContainer as the drop zone for all cards. This will also require a function to be run by the Droppable Component */}
                <Droppable
                    droppableId={"list-" + this.props.listId }
                >
                    {(provided: DroppableProvided) => {
                        return (
                            <div 
                                className="cardContainer" 
                                data-testid="cardList.cardContainer"
                                ref={provided.innerRef}
                            >
                                {/* Here we use curly brackets the same way we do with properties, only this time we are inserting an array */}
                                {cardComponents}

                                {/* This will allow the other draggables to reposition themselves to allow a gap for the card we are dragging  */}
                                {provided.placeholder}
                            </div>
                        )
                    }}
                </Droppable>
            </div>
        );
    }

{{partial_7}}}

{{partial_8}}